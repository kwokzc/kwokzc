<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git clone 速度太慢解决方案]]></title>
    <url>%2F2018%2F07%2F14%2Fgit-clone-proxy%2F</url>
    <content type="text"><![CDATA[在使用git clone时，速度一直只有几十kb，做了个路由后发现解析到了新加坡，并且是从日本绕到新加坡，延迟极高。修改host指定到洛杉矶后依然无法达到理想速度，待一番折腾后解决，记下操作。 环境 OS X 10.11 iTerm2 shadowsocksr git shadowsocksr配置查看shadowsocksr是ssr的mac版本，默认的http代理端口为1086，可在“HTTP代理设置”中查看和修改。 git配置12git config --global http.proxy 127.0.0.1:1087git config --global https.proxy 127.0.0.1:1087 以上两行配置了git的http和https代理，但是需要注意的是git clone的地址。如果是git@github.com开头则是以ssh协议进行访问，上边设置的代理对git clone的速度无效，那么我们需要转换地址。 转换git clone1234#原git clonegit clone git@github.com:powerline/fonts.git#更改后git clone https://github.com/powerline/fonts.git 最终效果]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 配置iptables 配合 shadowsocks]]></title>
    <url>%2F2016%2F06%2F20%2Fcentos-iptables-shadosocks%2F</url>
    <content type="text"><![CDATA[由于之前用CentOS 7.0配置iptables来配合shadowsocks时发现竟然time out，心想以为是防火墙混淆了或者是iptables配置上有些问题，为了系统干净所以直接重装了CentOS 6，以此来配置iptables。 下方有7.0设置方法 环境 CentOS 6 shadowsocks iptables 在安装了ss-bash后，ss-bash每添加一次port就会在iptables中的SSOUTPUT和SSINPUT中添加相对应的port作为ACCEPT，所以我们只需保留部分必备port，将其他端口DROP就可以了。 步骤初始化：首先进行一些初始化，清空所有现有的规则：iptables -F #清空所有链iptables -X #清空所有自定义链 定义规则：由于我们的目的是放弃所有无关于shadowsocks的数据，也就是说默认丢弃所有数据，只接受满足条件的数据，无疑是一种很安全的做法。 首先添加ssh端口：iptables -A INPUT -p tcp --dport 22 -j ACCEPT #22自行修改 添加以下六条规则：iptables -A INPUT -p icmp --icmp-type any -j ACCEPT #允许icmp包进入iptables -A INPUT -s localhost -d localhost -j ACCEPT #允许本地的数据包iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT #允许已经建立和相关的数据包进入iptables -A OUTPUT -p icmp --icmp any -j ACCEPT #允许icmp包出去iptables -A OUTPUT -s localhost -d localhost -j ACCEPT #允许本地数据包iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT #允许已经建立和相关的数据包出去 需要注意的是，以上的七条基本上是必须添加的；下面开始添加其他必要端口：iptables -A OUTPUT -p udp --dport 53 -j ACCEPT #打开DNS需要用到的53端口iptables -A OUTPUT -p tcp -m state --state NEW --dport 80 -j ACCEPT #允许80端口tcp协议的第一个数据包iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT #允许ESTABLISHED和RELATED状态的包iptables -A INPUT -P tcp --dport 443 -j ACCEPT #打开https需要用到的443端口 前面说道ss-bash自动添加ssserver端口到iptables中，我们便不再考虑ssserver的端口问题；此时还需要丢弃其他不在规则中的所有包：iptables -P INPUT DROP #默认丢弃input包iptables -p OUTPUT DROP #默认丢弃output包 service iptables save #保存配置service iptables restart #重启iptables请注意，重启命令如果是CentOS 6 可以这样执行，如果是7.0请继续往下看。 7.0设置iptables CentOS从7.0开始，默认防火墙更改为firewall，但如果想继续使用iptables，请按照一下命令执行： 关闭firewall：systemctl stop firewalld.service #关闭firewallsystemctl disable firewalld.service #禁止firewall开机启动安装iptables：yum install iptables-services #安装iptables;安装前可先‘iptables -L -n’测试是否安装之后按照以上的CentOS 6 进行配置，但需要注意的是，7.0的重启命令为：systemctl.restart iptables.service #重启iptables另外还需要设置开机启动（7.0）systemctl.enable iptables.service #设置iptables开机启动 至此，关于iptables配置已经完成 以下是关于iptables的一些资料，或许能够在你疑惑的时候对你有帮助： 关于iptables扩展iptables的state各个状态的含义： state只有四种状态：NEW，ESTABLISHED，RELATED 和INVALID它们主要是和状态匹配一起使用。 下面就简要地介绍以下这几种状态： Table 4-1. 数据包在用户空间的状态State（状态） Explanation（注释） NEW：NEW说明这个包是我们看到的第一个包。意思就是，这是conntrack模块看到的某个连接第一个包，它即将被匹配了。比如，我们看到一个SYN 包，是我们所留意的连接的第一个包，就要匹配它。第一个包也可能不是SYN包，但它仍会被认为是NEW状态。这样做有时会导致一些问题，但对某些情况是有非常大的帮助的。例如，在 我们想恢复某条从其他的防火墙丢失的连接时，或者某个连接已经超时，但实际上并未关闭时。 ESTABLISHED:ESTABLISHED已经注意到两个方向上的数据传输，而且会继续匹配这个连接的包。处于ESTABLISHED状态的连接是非常容易理解的。只要发送并接到应答，连接就是ESTABLISHED的了。一个连接要从NEW变 为ESTABLISHED，只需要接到应答包即可，不管这个包是发往防火墙的，还是要由防 火墙转发的。ICMP的错误和重定向等信息包也被看作是ESTABLISHED，只要它们是我们所发出的信息的应答。 RELATED:RELATED是个比较麻烦的状态。当一个连接和某个已处于ESTABLISHED状态的连接有关系时，就被认为是RELATED的了。换句话说，一个连接要想是RELATED的，首先要有一个ESTABLISHED的连接。这个ESTABLISHED连接再产生一个主连接之外的连接，这个新的连接就是RELATED的了，当然前提是conntrack模块要能理解RELATED。ftp是个很好的例子，FTP-data连接就是和FTP-control有RELATED的。还有其他的例子，比如，通过IRC的DCC连接。有了这个状态，ICMP应答、FTP传输、DCC等才能穿过防火墙正常工作。注意，大部分还有一些UDP协议都依赖这个机制。这些协议是很复杂的，它们把连接信息放在数据包里，并且要求这些信息能被正确理解。 INVALID:INVALID说明数据包不能被识别属于哪个连接或没有任何状态。有几个原因可以产生这种情况，比如，内存溢出，收到不知属于哪个连接的ICMP错误信息。一般地，我们DROP这个状态的任何东西。 另外还有一些描述更为简单的说明： NEW：当你在使用UDP、TCP、ICMP等协议时，发出的第一个包的状态就是“NEW”。 ESTABLISHED:当你在使用TCP、UDP、ICMP等协议时：假设你的主机发出的第一个包成功穿越防火墙，那么接下来你的主机 发出和接收到的包的状态都是“ESTABLISHED”。 RELATED:当你执行Linux下执行traceroute（Windows下对应的命令为tracert）命令时，这个traceroute会发出一个封包，该封包的TTL（生存时间，Time To Live）为1，当这个包遇到路由器的时候它的TTL会减少1，这时TTL = 0，然后这个包会被丢弃，丢弃这个包的路由器会返回一个ICMP Type 11的封包给你，并告诉你那个发出的数据包气数已尽。而这个ICMP Type 11的链接状态就是“RELATED”。 INVALID状态为INVALID的包就是状态不明的包，也就是不属于前面3中状态的包，这类包一般会被视为恶意包而被丢弃。 以上关于state的相关信息摘自ChinaUnix，感谢！]]></content>
      <tags>
        <tag>shadowsocks</tag>
        <tag>iptables</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎样成为全栈工程师？]]></title>
    <url>%2F2016%2F06%2F20%2FFull-Stack-Engineer%2F</url>
    <content type="text"><![CDATA[作者：顾鹏链接：https://www.zhihu.com/question/22420900/answer/21770992来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 做这样一个简单的 app:一个天气应用，干净清爽的界面，天气信息一目了然。它不仅可以精确预测未来 10 天的天气，还可以显示某地的历史天气信息。它具有自定义提醒功能，支持 web 版本， iOS 版， Android 版。 为什么想要做这样一个 App ？因为你喜欢旅行，但没找到一个天气 App 可以提供你下个月或者某个特定月份的天气信息；因为你懒你没有每天看天气预报的习惯，你想要在第二天温度达到 30 度以上或者温差有 +/-7 度的时候，获得温馨提示；因为你要成为一个 Full Stack Engineer ，你必须不断训练每个 stack 的能力。 Web版你决定用 MySql 来存储用户数据，用 NoSql 存储历史天气数据。你用 Redis 作为 cache ，缓存一些最常请求的天气数据。你用 Python 写后台，功能简单，后台不复杂，用户注册登录，抓取返回某城市的天气数据，某地的历史天气数据，很快便搞定。 后台开发并测试好了，接下来是 Web 前端。你十分清楚一个好的 UI 设计对一个 App 的重要性，你也明白 UI 的设计不只是为了美观，更重要的是提高信息的可读性和程序的可用性。幸好你平日的积累这次派上用场了。你把之前保存下来的上百个优秀的UI设计作品拿来研究，你从书架上拿出Norman 的那本经典 - The Design of Everyday Things 重新细读。最终你用白纸黑笔敲定了第一个版本的 UI，简洁直观，没有任何多余的设计，所有元素的排列间距 大小颜色都恰到好处。你相信即使天气不好，但用户只要使用这个 App 都会有着愉悦的心情。 那么开始写前端吧。啊，别急，都忘了还有 Icon 和 Logo ，可是不会 PS ，不会 AI ，不会 Sketch 怎么办呢，学吧。你平日喜欢结交不同领域的朋友，正好几周前在一个活动上你认识一位朋友做设计的。她花一个下午的时间教你基本的 Sketch 的使用，并对你的 UI 设计给出了一些意见。你请她吃了顿晚饭表示感谢，然后立即回家根据她的一些建议重新调整了 UI ，这次你在 PS 里把 UI 画了出来，Icons 和 Logo 也顺道一起做了。 接下来的一周，你学习 HTML，CSS，以及 Javascript，并漂亮地把前端搞定。 发布 App在朋友圈发了个状态，找人帮你做 Beta 测试。他们都首先问你是什么 App，一开始你简单回答一个天气的 App。但你发现，这不能提起他们的兴趣。你觉得你需要用语言，用故事包装一下。不光是作为别人「是什么 App」提问的回答，也是成为 Full stack Engineer 道路上的一个重要技能。 你去看了所有你喜欢的产品的主页，从他们的文案上获得一些灵感启发；你读了经典的 On Writing Well ，发现好的文案，好的设计，其实和好的代码很相似，都是重在交流，如何让他人毫不费劲地明白你要表达的内容。你的故事要吸引人，你的产品介绍要在1分钟内解释清楚，并确保你的父母可以毫无压力听明白。 一切就绪，产品上线了。反响不错，用户持续增加。很多用户希望有移动版本，于是你立即投入到iOS 版本的开发上。 iOS 版 及 后台优化你花一周不到时间学习了基本的语法和工具使用便投入到 App 的开发中。你知道 Learn by Doing 是最好也是最快的。由于之前学习了设计的基础，UI ，Icons 很快搞定，不久 iOS 版本便发布了。iOS 的发布带来了更多的用户增长，后台服务器的压力颇大，你知道是时候优化后台了。 你在 AWS 上多开了 2 台服务器，并写了一个 Script 来自动化部署过程。你改用 uWSGi 协议，用 uwsgi 作为 Application Server。你使用 Nginx 来做并发，负载均衡 …………… 成立公司用户持续增长，每天你都会收到十几二十封用户的邮件。你很感激这些愿意花时间给你写邮件的用户，你相信他们是你最重要的用户，是潜在的付费用户。如果你把他们像上帝一样对待，他们同样也会把你看作是上帝。所以除了睡觉时间的发来的邮件，每一封邮件，你都会在2小时内给予回复。 果然这样的付出是收获巨大的，他们不仅惊讶且非常感谢你的快速回复，他们会在app store里给你★★★★★的评价，他们在社交网站上分享你的app，他们甚至会主动提出捐款给你。 你从快速的用户增长中嗅到了商机，你开始思考如何赚钱。广告你是坚决不能允许的，你认为再精确的广告也会影响用户体验。你设计了 2 个不同的付费方案，你打算用 A/B 测试看哪个方案更好。你分别给 200 个用户发去邀请尝试付费的邮件，邮件内容你精心打磨过，并在最后写上：CEO &amp; Founder. 通过分析 2 种方案的用户行为，你决定将使用第一种方案。 接下来，你相信差不多是时候成立个公司了。为了省时间，你花 2000 块钱找了个园区挂靠并帮你注册公司。公司的名字让你头疼了很久，你不想只是简单的用这个 App 的名字作为公司名字，你知道公司将来还会做出其他优秀的产品。你希望这个名字简单易记，同时其含义也是你公司文化的象征。 公司注册下来了，但银行那边得自己跑。你联系了一些媒体编辑，邀请他们来试用你的产品；你重新设计了产品主页，并开始写产品的 Blog ；你在各大社交网络都给 App 注册了账号，即做社区客服也为宣传… 这些事大大压缩你写代码的时间。以往你都是以代码量作为衡量自己当天工作效率的指标，所以这些天你总感觉没做啥工作。 这样的发展早已超过你的预期，这个 App 从一个 Side Project 几乎变成了你生活的全部。你跟你女朋友半个月才出去约会一次，她抱怨不断；你1个月没跟朋友出去玩耍喝酒了；你 2 个月都没锻炼过身体… 你意识到, YOU CAN NOT DO THIS ALONE，你需要帮手，你需要找人一起把这个做下去。 但你不是要成为 Full Stack Engineer 么？你现在是了么？ Full Stack Engineer设计，后台开发，前端开发，移动开发，运营维护，PS，文案… 好像都会了，这算 Full Stack Engineer 了么？ 不，这只是踏上成为 Full Stack Engineer 的第一步。你知道目前只是每个 stack 都懂一点，离senior 或者 expert 还差得远，而要每个 stack 都做到极致，需要大量的时间和精力。精力有限，产品开发紧迫，力不从心啊，这条道路也太孤独，因为你不需要与任何人进行协作。难道要把一些stack的任务交给别人做么？这样算是放弃成为 Full Stack Engineer 么？ 不！这不是。什么是 Engineer？「Engineers are versatile minds who create links between science, technology, and society」。Engineer 的本质工作是设计，开发出应用于大众的产品。 一个真正的 Full Stack Engineer ，他从生活中发现问题，洞察需求，他设计解决方案，并开发出初始版本的产品。为了达到目标，他愿意去学习任何领域的技能和知识。同时他不追求一个人完成所有工作，如果有人可以比他在某方面做得更出色，便会十分热情的邀请他们加入。 最终他的职位也许不再是 Engineer ，他不再设计 UI ，不再写代码 … 他的工作不再是 design and building an app or product，因为他有更大更重要的任务要做 - design and building a team or a company which builds great products. 而这时，社会给了他们另一个称呼 - 创业者。尽管众人已忘记他们 Engineer 的身份，但在他们骨子里，内心深处，自己始终都是一个 Engineer 。当他们需要从头再来时，他们毫不犹豫从设计开发产品做起。Nikola Tesla，Ferdinand Porsche，Henry Ford，Jack Dorsey，Mark zuckerberg，Elon Musk … 细数那些改变了或正改变世界的创业者，他们大多数是 Engineer 背景，热衷于设计创造。他们学习技能和知识，不是为了成为某个领域的专家；而是因为那些 是完成自己目标所需要的。 以上，为我认可的 Full Stack Engineer]]></content>
      <tags>
        <tag>成长</tag>
      </tags>
  </entry>
</search>
